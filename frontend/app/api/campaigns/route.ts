import { NextResponse } from 'next/server';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';

export const dynamic = 'force-dynamic';

// Try to read cached data from public/data.json (generated by tracker script)
function getCachedData() {
  try {
    const cachePath = join(process.cwd(), 'public', 'data.json');
    if (existsSync(cachePath)) {
      const data = JSON.parse(readFileSync(cachePath, 'utf8'));
      // Only use if less than 2 hours old
      const age = Date.now() - new Date(data.timestamp).getTime();
      if (age < 2 * 60 * 60 * 1000) {
        return data;
      }
    }
  } catch {}
  return null;
}

async function fetchJson(url: string, timeout = 10000) {
  const controller = new AbortController();
  const tid = setTimeout(() => controller.abort(), timeout);
  try {
    const res = await fetch(url, {
      headers: { Accept: 'application/json' },
      signal: controller.signal,
      cache: 'no-store',
    });
    clearTimeout(tid);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  } catch (e) {
    clearTimeout(tid);
    throw e;
  }
}

async function getEthPrice(): Promise<number> {
  try {
    const d = await fetchJson('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
    return d.ethereum?.usd ?? 2000;
  } catch {
    return 2000;
  }
}

async function fetchRallyCampaigns() {
  const all: any[] = [];
  for (let page = 1; page <= 3; page++) {
    try {
      const d = await fetchJson(`https://app.rally.fun/api/campaigns?page=${page}&limit=50`);
      all.push(...(d.campaigns ?? []));
      if (!d.pagination?.hasNext) break;
    } catch { break; }
  }
  return all;
}

async function fetchSubmissions(ic: string) {
  try {
    const raw = await fetchJson(`https://app.rally.fun/api/submissions?campaignAddress=${ic}&limit=5000`, 8000);
    return Array.isArray(raw) ? raw : Object.values(raw);
  } catch { return []; }
}

function formatPrize(reward: any, symbol: string | undefined): string | null {
  if (!reward) return null;
  const n = Number(reward.totalAmount);
  const sym = symbol ?? '';
  if (n >= 1e9) return `${(n / 1e9).toFixed(0)}B ${sym}`;
  if (n >= 1e6) return `${(n / 1e6).toFixed(0)}M ${sym}`;
  if (n >= 1e3) return `${(n / 1e3).toFixed(0)}K ${sym}`;
  return `${n} ${sym}`;
}

export async function GET() {
  try {
    // Try cached data first (has on-chain fee info)
    const cached = getCachedData();
    
    // Always fetch fresh Rally data for user/submission counts
    const [ethPrice, rallyCampaigns] = await Promise.all([
      getEthPrice(),
      fetchRallyCampaigns(),
    ]);

    const now = new Date();
    const activeCampaigns = rallyCampaigns.filter((c: any) => new Date(c.endDate) > now);

    // Build lookup for cached on-chain data by IC address
    const cachedByIC: Record<string, any> = {};
    if (cached?.feeCampaigns) {
      for (const c of cached.feeCampaigns) {
        if (c.ic) cachedByIC[c.ic.toLowerCase()] = c;
      }
    }

    // Merge Rally data with cached on-chain data
    const campaigns = await Promise.all(
      activeCampaigns.slice(0, 15).map(async (camp: any) => {
        const ic = camp.intelligentContractAddress;
        const cachedData = ic ? cachedByIC[ic.toLowerCase()] : null;

        let users = 0, submissions = 0, approved = 0, rejected = 0, avgScore = 0;
        if (ic) {
          const subs = await fetchSubmissions(ic);
          submissions = subs.length;
          rejected = subs.filter((s: any) => s.disqualifiedAt || s.hiddenAt || s.invalidatedAt).length;
          approved = submissions - rejected;
          users = new Set(subs.map((s: any) => s.userXId)).size;
          const scores = subs.filter((s: any) => s.atemporalPoints).map((s: any) => {
            try { return Number(BigInt(s.atemporalPoints)) / 1e18; } catch { return 0; }
          });
          avgScore = scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
        }

        const remainDays = Math.max(0, (new Date(camp.endDate).getTime() - now.getTime()) / 86400000);

        return {
          title: camp.title,
          address: ic ?? camp.campaignContractAddress ?? '',
          creator: camp.displayCreator?.xUsername ?? null,
          prize: formatPrize(camp.campaignRewards?.[0], camp.token?.symbol),
          users,
          submissions,
          approved,
          rejected,
          avgScore,
          remainDays: Math.ceil(remainDays),
          // On-chain data from cache
          revenueUsd: cachedData?.revenueUsd ?? null,
          participants: cachedData?.participants ?? null,
          failedTxs: cachedData?.failedTxs ?? 0,
          ghostWallets: cachedData?.ghostWallets ?? 0,
        };
      })
    );

    campaigns.sort((a, b) => (b.revenueUsd ?? b.users) - (a.revenueUsd ?? a.users));

    // Stats
    const totalUsers = campaigns.reduce((sum, c) => sum + c.users, 0);
    const totalSubmissions = campaigns.reduce((sum, c) => sum + c.submissions, 0);
    const totalRevenue = cached?.stats?.totalRevenue ?? campaigns.reduce((sum, c) => sum + (c.revenueUsd ?? 0), 0);
    const totalParticipants = cached?.stats?.totalParticipants ?? 0;

    return NextResponse.json({
      timestamp: new Date().toISOString(),
      cachedAt: cached?.timestamp ?? null,
      ethPrice,
      campaigns,
      stats: {
        totalCampaigns: rallyCampaigns.length,
        activeCampaigns: activeCampaigns.length,
        totalUsers,
        totalSubmissions,
        totalRevenue,
        totalParticipants,
        totalFailedTxs: cached?.stats?.totalFailedTxs ?? 0,
        ghostWallets: cached?.stats?.ghostWallets ?? 0,
      },
    });
  } catch (error: any) {
    console.error('API Error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
